"use strict";(self.webpackChunkjspecify=self.webpackChunkjspecify||[]).push([[659],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>c});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var o=a.createContext({}),s=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(o.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,i=e.originalType,o=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),m=s(t),c=l,N=m["".concat(o,".").concat(c)]||m[c]||d[c]||i;return t?a.createElement(N,r(r({ref:n},u),{},{components:t})):a.createElement(N,r({ref:n},u))}));function c(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var i=t.length,r=new Array(i);r[0]=m;var p={};for(var o in n)hasOwnProperty.call(n,o)&&(p[o]=n[o]);p.originalType=e,p.mdxType="string"==typeof e?e:l,r[1]=p;for(var s=2;s<i;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6726:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var a=t(7462),l=(t(7294),t(3905));const i={sidebar_position:2},r="Nullness User Guide (draft)",p={unversionedId:"user-guide",id:"user-guide",title:"Nullness User Guide (draft)",description:"In Java code, whether an expression may evaluate to null is often documented",source:"@site/docs/user-guide.md",sourceDirName:".",slug:"/user-guide",permalink:"/docs/user-guide",draft:!1,editUrl:"https://github.com/jspecify/jspecify/tree/main/docs/docs/user-guide.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Start Here",permalink:"/docs/start-here"},next:{title:"Nullness Specification (draft)",permalink:"/docs/spec"}},o={},s=[{value:"Java variables are references",id:"java-variables-are-references",level:2},{value:"Types and nullness",id:"types-and-nullness",level:2},{value:"<code>@Nullable</code>",id:"nullable",level:2},{value:"<code>@NullMarked</code>",id:"nullmarked",level:2},{value:"Local variables",id:"local-variables",level:2},{value:"Generics",id:"generics",level:2},{value:"Defining generic types",id:"defining-generics",level:3},{value:"Using type variables in generic types",id:"using-type-variables-in-generic-types",level:3},{value:"Using type variables in generic methods",id:"using-type-variables-in-generic-methods",level:3},{value:"Some subtler details",id:"some-subtler-details",level:2},{value:"Type-use annotation syntax",id:"type-use-annotation-syntax",level:3},{value:"Wildcard bounds",id:"wildcard-bounds",level:3}],u={toc:s};function d(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"nullness-user-guide-draft"},"Nullness User Guide (draft)"),(0,l.kt)("p",null,"In Java code, whether an expression may evaluate to null is often documented\nonly in natural language, if at all. The goal of JSpecify is to permit\nprogrammers to express specifications (initially, just nullness properties) in a\nmachine-readable way."),(0,l.kt)("p",null,"JSpecify defines annotations that describe whether a Java type contains the\nvalue null. Such annotations are useful to (for example):"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"programmers reading the code,"),(0,l.kt)("li",{parentName:"ul"},"tools that help developers avoid NullPointerExceptions,"),(0,l.kt)("li",{parentName:"ul"},"tools that perform run-time checking and test generation, and"),(0,l.kt)("li",{parentName:"ul"},"documentation systems.")),(0,l.kt)("h2",{id:"java-variables-are-references"},"Java variables are references"),(0,l.kt)("p",null,"In Java, all non-primitive variables are references. We often think of ",(0,l.kt)("inlineCode",{parentName:"p"},"String\nx"),' as meaning "',(0,l.kt)("inlineCode",{parentName:"p"},"x")," is a ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),'", but actually it means "',(0,l.kt)("inlineCode",{parentName:"p"},"x")," is a ",(0,l.kt)("em",{parentName:"p"},"reference"),',\neither null or a reference to a string object".'),(0,l.kt)("p",null,"JSpecify includes a ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked")," annotation. In code covered by that\nannotation, ",(0,l.kt)("inlineCode",{parentName:"p"},"String x"),' means "',(0,l.kt)("inlineCode",{parentName:"p"},"x"),' is a reference to a string object", and\n',(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String x"),' means "',(0,l.kt)("inlineCode",{parentName:"p"},"x"),' is either null or a reference to a string\nobject"'),(0,l.kt)("h2",{id:"types-and-nullness"},"Types and nullness"),(0,l.kt)("p",null,"Each reference can have one of three possible properties regarding nullness:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"JSpecify annotations indicate that it can be null."),(0,l.kt)("li",{parentName:"ol"},"JSpecify annotations indicate that it can't be null."),(0,l.kt)("li",{parentName:"ol"},"JSpecify annotations don't indicate whether it can be null.")),(0,l.kt)("p",null,"For a given reference ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),", if ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," can be null then ",(0,l.kt)("inlineCode",{parentName:"p"},"x.getClass()")," is unsafe\nbecause it could produce a NullPointerException. If ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," can't be null,\n",(0,l.kt)("inlineCode",{parentName:"p"},"x.getClass()")," can never produce a NullPointerException. If JSpecify annotations\nhaven't said whether ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," can be null or not, we don't know whether\n",(0,l.kt)("inlineCode",{parentName:"p"},"x.getClass()")," is safe (at least as far as JSpecify is concerned)."),(0,l.kt)("p",null,"There are two JSpecify annotations that indicate these properties:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," applied to a type means a reference of that type can be null.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked")," applied to a module, package, or class means that a reference\nin that scope can't be null unless its type is explicitly marked\n",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable"),". (Below we will see that there are some exceptions to this for\n",(0,l.kt)("a",{parentName:"p",href:"#local-variables"},"local variables")," and\n",(0,l.kt)("a",{parentName:"p",href:"#defining-generics"},"type variables"),".)"))),(0,l.kt)("p",null,'The notion of "can\'t be null" should really be read with a footnote that says\n"if all the code in question is ',(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),'". For example, if you have some\ncode that is not ',(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked")," and that calls a ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),' method, then tools\nmight allow it to pass a possibly-null value to a method that is expecting a\n"can\'t be null" parameter.'),(0,l.kt)("h2",{id:"nullable"},(0,l.kt)("inlineCode",{parentName:"h2"},"@Nullable")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," annotation applied to a type means that that use of the type\nincludes references that can be null. Code that deals with those references must\nbe able to deal with the null case."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"static void print(@Nullable String x) {\n  System.out.println(String.valueOf(x));\n}\n")),(0,l.kt)("p",null,"In this example, the parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," can be null, so ",(0,l.kt)("inlineCode",{parentName:"p"},"print(null)")," is a valid\nmethod call. The body of the ",(0,l.kt)("inlineCode",{parentName:"p"},"print")," method does not do anything with ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," that\nwould provoke a NullPointerException so this method is safe."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"static @Nullable String emptyToNull(@Nullable String x) {\n  return (x == null || x.isEmpty()) ? null : x;\n}\n")),(0,l.kt)("p",null,"In this example, the parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," can still be null, but now the return value\ncan be too. You might use this method like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"void doSomething(@Nullable String x) {\n  print(emptyToNull(x));\n  // OK: print accepts a @Nullable String\n\n  String z = emptyToNull(x).toString();\n  // Not OK: emptyToNull(x) can be null\n}\n")),(0,l.kt)("p",null,"Tools could then use the ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," information to determine that the first use\nis safe but the second is not."),(0,l.kt)("p",null,"As far as JSpecify is concerned, ",(0,l.kt)("inlineCode",{parentName:"p"},"String")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String")," are ",(0,l.kt)("em",{parentName:"p"},"different"),"\ntypes. A variable of type ",(0,l.kt)("inlineCode",{parentName:"p"},"String")," can reference any string object. A variable\nof type ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String")," can too, but it can also be null. This means that\n",(0,l.kt)("inlineCode",{parentName:"p"},"String")," is a ",(0,l.kt)("em",{parentName:"p"},"subtype")," of ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String"),", in the same way that ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer")," is\na subtype of ",(0,l.kt)("inlineCode",{parentName:"p"},"Number"),". One way to look at this is that a subtype narrows the\nrange of possibilities. A ",(0,l.kt)("inlineCode",{parentName:"p"},"Number")," variable can be assigned from an ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer"),"\nbut it can also be assigned from a ",(0,l.kt)("inlineCode",{parentName:"p"},"Long"),". Meanwhile an ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer")," variable can't\nbe assigned from a ",(0,l.kt)("inlineCode",{parentName:"p"},"Number")," (since that ",(0,l.kt)("inlineCode",{parentName:"p"},"Number")," might be a ",(0,l.kt)("inlineCode",{parentName:"p"},"Long")," or some other\nsubtype). Likewise, a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String")," can be assigned from a ",(0,l.kt)("inlineCode",{parentName:"p"},"String")," but a\n",(0,l.kt)("inlineCode",{parentName:"p"},"String")," can't be assigned from a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String")," (since that might be null)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@NullMarked\nclass Example {\n  void useNullable(@Nullable String x) {...}\n  void useNonNull(String x) {...}\n  void example(@Nullable String nullable, String nonNull) {\n    useNullable(nonNull); // JSpecify allows this\n    useNonNull(nullable); // JSpecify doesn't allow this\n  }\n}\n")),(0,l.kt)("h2",{id:"nullmarked"},(0,l.kt)("inlineCode",{parentName:"h2"},"@NullMarked")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked")," annotation indicates that references can't be null in its\nscope, unless their types are explicitly marked ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable"),". If applied to a\nmodule then its scope is all the code in the module. If applied to a package\nthen its scope is all the code in the package. If applied to a class or\ninterface then its scope is all the code in that class or interface."),(0,l.kt)("p",null,"Outside ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String")," still means a reference that can be\nnull, but JSpecify doesn't have anything to say about whether plain ",(0,l.kt)("inlineCode",{parentName:"p"},"String")," can\nbe null."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@NullMarked\npublic class Strings {\n  public static String nullToEmpty(@Nullable String x) {\n    return (x == null) ? \"\" : x;\n  }\n\n  public static int spaceIndex(String x) {\n    return x.indexOf(' ');\n  }\n}\n")),(0,l.kt)("p",null,"In this example, both methods are in the scope of ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),", so plain\n",(0,l.kt)("inlineCode",{parentName:"p"},"String"),' means "a reference to a string object, not null". ',(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String"),'\ncontinues to mean "a reference to a string object, or null". Tools should warn\nyou if you try to pass a "reference to a string object, or null" to\n',(0,l.kt)("inlineCode",{parentName:"p"},"spaceIndex"),", since its argument can't be null, and indeed it will throw\nNullPointerException if given a null argument."),(0,l.kt)("p",null,"As mentioned above, there are some exceptions to this interpretation for local\nvariables (as we'll see next) and ",(0,l.kt)("a",{parentName:"p",href:"#defining-generics"},"type variables"),"."),(0,l.kt)("h2",{id:"local-variables"},"Local variables"),(0,l.kt)("p",null,"Tools that understand JSpecify annotations typically ",(0,l.kt)("em",{parentName:"p"},"don't")," require ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable"),"\nto be applied to local variables. They may in fact not even allow that. The\nreason is that it should be possible to ",(0,l.kt)("em",{parentName:"p"},"infer")," whether a variable can be null\nbased on the values that are assigned to the variable. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@NullMarked\nclass MyClass {\n  void myMethod(@Nullable String one, String two) {\n    String anotherOne = one;\n    String anotherTwo = two;\n    String oneOrTwo = random() ? one : two;\n    String twoOrNull = Strings.emptyToNull(two);\n    ...\n  }\n}\n")),(0,l.kt)("p",null,"Analysis can tell that all of these variables except ",(0,l.kt)("inlineCode",{parentName:"p"},"anotherTwo")," can be null.\n",(0,l.kt)("inlineCode",{parentName:"p"},"anotherTwo")," can't be null since ",(0,l.kt)("inlineCode",{parentName:"p"},"two")," can't be null: it is not ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," and\nit is inside the scope of ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"anotherOne")," can be null since it is\nassigned from a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," parameter. ",(0,l.kt)("inlineCode",{parentName:"p"},"oneOrTwo")," can be null because it may\nassigned from a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," parameter. And ",(0,l.kt)("inlineCode",{parentName:"p"},"twoOrNull")," can be null because its\nvalue comes from a method that returns ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String"),"."),(0,l.kt)("h2",{id:"generics"},"Generics"),(0,l.kt)("p",null,"When you are referencing a generic type, the rules about ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked")," are as you would expect from what we have seen. For example,\n",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable String>")," means a list where each element is either a reference\nto a string object or it is null. In a ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked")," context, ",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>"),"\nmeans a list where each element is a reference to a string object and ",(0,l.kt)("em",{parentName:"p"},"can't")," be\nnull."),(0,l.kt)("h3",{id:"defining-generics"},"Defining generic types"),(0,l.kt)("p",null,"Things are a bit more complicated when you are ",(0,l.kt)("em",{parentName:"p"},"defining")," a generic type.\nConsider this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@NullMarked\npublic class NumberList<E extends Number> implements List<E> {...}\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"extends Number")," defines a ",(0,l.kt)("em",{parentName:"p"},"bound")," for the type variable ",(0,l.kt)("inlineCode",{parentName:"p"},"E"),". It means that\nyou can write ",(0,l.kt)("inlineCode",{parentName:"p"},"NumberList<Integer>"),", since ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer")," can be assigned to\n",(0,l.kt)("inlineCode",{parentName:"p"},"Number"),", but you can't write ",(0,l.kt)("inlineCode",{parentName:"p"},"NumberList<String>"),", since ",(0,l.kt)("inlineCode",{parentName:"p"},"String")," can't be\nassigned to ",(0,l.kt)("inlineCode",{parentName:"p"},"Number"),". This is standard Java behavior."),(0,l.kt)("p",null,"But now let's think about that bound as it relates to ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),". Can we\nwrite ",(0,l.kt)("inlineCode",{parentName:"p"},"NumberList<@Nullable Integer>"),"? The answer is no, because we have ",(0,l.kt)("inlineCode",{parentName:"p"},"<E\nextends Number>")," inside ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),". Since it is ",(0,l.kt)("inlineCode",{parentName:"p"},"Number")," and not ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable\nNumber"),", that means it can't be null. ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable Integer")," can't be assigned to\nit, since that ",(0,l.kt)("em",{parentName:"p"},"can")," be null. Inside ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),", you must explicitly provide\na ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," bound on your type variable if you want it to be able to represent\na ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," type:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@NullMarked\npublic class NumberList<E extends @Nullable Number> implements List<E> {...}\n")),(0,l.kt)("p",null,"Now it ",(0,l.kt)("em",{parentName:"p"},"is")," legal to write ",(0,l.kt)("inlineCode",{parentName:"p"},"NumberList<@Nullable Integer"),">, since ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable\nInteger")," is assignable to the bound ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable Number"),". It's ",(0,l.kt)("em",{parentName:"p"},"also")," legal to\nwrite ",(0,l.kt)("inlineCode",{parentName:"p"},"NumberList<Integer>"),", since plain ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer")," is assignable to ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable\nNumber"),". Inside ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),", plain ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer")," means a reference to an actual\n",(0,l.kt)("inlineCode",{parentName:"p"},"Integer")," value, never null. That just means that the ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable Number")," can\ntechnically be null but in this case it never will be."),(0,l.kt)("p",null,"Of course this assumes that ",(0,l.kt)("inlineCode",{parentName:"p"},"List")," itself is written in a way that allows null:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@NullMarked\npublic interface List<E extends @Nullable Object> {...}\n")),(0,l.kt)("p",null,"If it were ",(0,l.kt)("inlineCode",{parentName:"p"},"interface List<E>")," rather than ",(0,l.kt)("inlineCode",{parentName:"p"},"interface List<E extends @Nullable\nObject>")," then ",(0,l.kt)("inlineCode",{parentName:"p"},"NumberList<E extends @Nullable Number> implements List<E>")," would not\nbe legal. That's because ",(0,l.kt)("inlineCode",{parentName:"p"},"interface List<E>")," is short for ",(0,l.kt)("inlineCode",{parentName:"p"},"interface List<E\nextends Object>"),". Inside ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),", plain ",(0,l.kt)("inlineCode",{parentName:"p"},"Object"),' means "',(0,l.kt)("inlineCode",{parentName:"p"},"Object")," reference\nthat can't be null\". The ",(0,l.kt)("inlineCode",{parentName:"p"},"<E extends @Nullable Number>")," from NumberList would\nnot be compatible with ",(0,l.kt)("inlineCode",{parentName:"p"},"<E extends Object>"),"."),(0,l.kt)("p",null,"The implication of all this is that every time you define a type variable like\n",(0,l.kt)("inlineCode",{parentName:"p"},"E")," you need to decide whether it can represent a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," type. If it can,\nthen it must have a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," bound. Most often this will be ",(0,l.kt)("inlineCode",{parentName:"p"},"<E extends\n@Nullable Object>"),". On the other hand, if it ",(0,l.kt)("em",{parentName:"p"},"can't")," represent a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable"),"\ntype, that is expressed by not having ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," in its bound (including the\ncase of not having an explicit bound at all). Here's another example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@NullMarked\npublic class ImmutableList<E> implements List<E> {...}\n")),(0,l.kt)("p",null,"Here, because it is ",(0,l.kt)("inlineCode",{parentName:"p"},"ImmutableList<E>")," and not ",(0,l.kt)("inlineCode",{parentName:"p"},"ImmutableList<E extends\n@Nullable Object>"),", it is not legal to write ",(0,l.kt)("inlineCode",{parentName:"p"},"ImmutableList<@Nullable String>"),".\nYou can only write ",(0,l.kt)("inlineCode",{parentName:"p"},"ImmutableList<String>"),", which is a list of non-null ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),"\nreferences."),(0,l.kt)("h3",{id:"using-type-variables-in-generic-types"},"Using type variables in generic types"),(0,l.kt)("p",null,"Let's look at what the methods in the ",(0,l.kt)("inlineCode",{parentName:"p"},"List")," interface might look like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@NullMarked\npublic interface List<E extends @Nullable Object> {\n  boolean add(E element);\n  E get(int index);\n  @Nullable E getFirst();\n  ...\n}\n")),(0,l.kt)("p",null,"The parameter type ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," of ",(0,l.kt)("inlineCode",{parentName:"p"},"add")," means a reference that is compatible with the\nactual type of the ",(0,l.kt)("inlineCode",{parentName:"p"},"List")," elements. Just as you can't add an ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer")," to a\n",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>"),", you also can't add a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String")," to a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>"),", but\nyou ",(0,l.kt)("em",{parentName:"p"},"can")," add it to a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable String>"),"."),(0,l.kt)("p",null,"Similarly, the return type ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," of ",(0,l.kt)("inlineCode",{parentName:"p"},"get")," means that it returns a reference with\nthe actual type of the list elements. If the list is a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable String>"),"\nthen that reference is a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String"),". If the list is a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>"),"\nthen the reference is a ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,l.kt)("p",null,"On the other hand, the return type ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable E")," of the (fictitious) ",(0,l.kt)("inlineCode",{parentName:"p"},"getFirst"),"\nmethod is always ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable"),". It will be ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String")," whether called on a\n",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable String>")," or a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>"),". The idea is that the method\nreturns the first element of the list, or null if the list is empty. Similarly,\nthe real methods ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable V get(Object key)")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"Map")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable E peek()"),"\nin ",(0,l.kt)("inlineCode",{parentName:"p"},"Queue")," can return null even when ",(0,l.kt)("inlineCode",{parentName:"p"},"V")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," can't be null."),(0,l.kt)("p",null,"The distinction here is an important one that is worth repeating. A use of a\ntype variable like ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," should only be ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable E")," if it means a reference that\ncan be null ",(0,l.kt)("em",{parentName:"p"},"even if")," ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," itself can't be null. Otherwise, plain ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," means a\nreference that can only be null if ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," is a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," type, like ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable\nString")," in this example. (And, as we've seen, ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," can only be a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," type\nif the definition of ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," has a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," bound like ",(0,l.kt)("inlineCode",{parentName:"p"},"<E extends @Nullable\nObject>"),".)"),(0,l.kt)("p",null,"We saw earlier that ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked")," usually means \"references can't be null unless\nthey are marked ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable"),"\", and also that that doesn't apply to local\nvariables. Here we see that it doesn't apply to type variable uses either. When\nnot marked ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable"),", they can still be null if they have a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," bound."),(0,l.kt)("h3",{id:"using-type-variables-in-generic-methods"},"Using type variables in generic methods"),(0,l.kt)("p",null,"Essentially the same considerations that we just saw with generic types apply to\ngeneric methods too. Here's an example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@NullMarked\npublic class Methods {\n  public static <T> @Nullable T\n      firstOrNull(List<T> list) {\n    return list.isEmpty() ? null : list.get(0);\n  }\n\n  public static <T> T\n      firstOrNonNullDefault(List<T> list, T defaultValue) {\n    return list.isEmpty() ? defaultValue : list.get(0);\n  }\n\n  public static <T extends @Nullable Object> T\n      firstOrDefault(List<T> list, T defaultValue) {\n    return list.isEmpty() ? defaultValue : list.get(0);\n  }\n\n  public static <T extends @Nullable Object> @Nullable T\n      firstOrNullableDefault(List<T> list, @Nullable T defaultValue) {\n    return list.isEmpty() ? defaultValue : list.get(0);\n  }\n}\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"firstOrNull")," method will accept a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>")," but not a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable\nString>"),". When given an argument of type ",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),", so the\nreturn type ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable T")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String"),". The input list can't contain\nnull elements, but the return value can be null."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"firstOrNonNullDefault")," method again does not allow ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," to be a ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable"),"\ntype, so ",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable String>")," is not allowed. Now the return value is not\n",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," either which means it will never be null."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"firstOrDefault")," method will accept both ",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable\nString>"),". In the first case, ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),", so the type of the ",(0,l.kt)("inlineCode",{parentName:"p"},"defaultValue"),"\nparameter and of the return value is ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),", meaning neither can be null. In\nthe second case, ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String"),", so the type of ",(0,l.kt)("inlineCode",{parentName:"p"},"defaultValue")," and of\nthe return value is ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String"),", meaning both can be null."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"firstOrNullableDefault")," method again accepts both ",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable String>"),", but now the ",(0,l.kt)("inlineCode",{parentName:"p"},"defaultValue")," parameter is marked\n",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," so it can be null even in the ",(0,l.kt)("inlineCode",{parentName:"p"},"List<String>")," case. Likewise the\nreturn value is ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable T")," so it can be null even when ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," can't."),(0,l.kt)("p",null,"Here's another example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public static <T> List<@Nullable T> nullOutMatches(List<T> list, T toRemove) {\n  List<@Nullable T> copy = new ArrayList<>(list);\n  for (int i = 0; i < copy.size(); i++) {\n    if (copy.get(i).equals(toRemove)) {\n      copy.set(i, null);\n    }\n  }\n  return copy;\n}\n")),(0,l.kt)("p",null,"This takes a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<T>"),", which by definition does not contain null elements, and\nproduces a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable T>"),", with null in place of every element that matched\n",(0,l.kt)("inlineCode",{parentName:"p"},"toRemove"),". The output is a ",(0,l.kt)("inlineCode",{parentName:"p"},"List<@Nullable T>")," because it ",(0,l.kt)("em",{parentName:"p"},"can")," contain null\nelements, even if ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," itself can't be null."),(0,l.kt)("h2",{id:"some-subtler-details"},"Some subtler details"),(0,l.kt)("p",null,"The previous sections cover 99% of everything you need to know to be able to use\nJSpecify annotations effectively. Here we'll cover a few details you probably\nwon't need to know."),(0,l.kt)("h3",{id:"type-use-annotation-syntax"},"Type-use annotation syntax"),(0,l.kt)("p",null,"There are a couple of places where the syntax of type-use annotations like\n",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," may be surprising."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For a nested static type like ",(0,l.kt)("inlineCode",{parentName:"p"},"Map.Entry"),", if you want to say that the value\ncan be null then the syntax is ",(0,l.kt)("inlineCode",{parentName:"p"},"Map.@Nullable Entry"),". You can often avoid\ndealing with this by importing the nested type directly, but in this case\n",(0,l.kt)("inlineCode",{parentName:"p"},"import java.util.Map.Entry")," might be undesirable because ",(0,l.kt)("inlineCode",{parentName:"p"},"Entry")," is such a\ncommon type name.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For an array type, if you want to say that the ",(0,l.kt)("em",{parentName:"p"},"elements")," of the array can\nbe null then the syntax is ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String[]"),". If you want to say that the\n",(0,l.kt)("em",{parentName:"p"},"array itself")," can be null then the syntax is ",(0,l.kt)("inlineCode",{parentName:"p"},"String @Nullable []"),". And if\nboth the elements and the array itself can be null, the syntax is ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable\nString @Nullable []"),"."))),(0,l.kt)("p",null,"A good way to remember this is that it is the thing right after ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," that\ncan be null. It is the ",(0,l.kt)("inlineCode",{parentName:"p"},"Entry")," that can be null in ",(0,l.kt)("inlineCode",{parentName:"p"},"Map.@Nullable Entry"),", not\nthe ",(0,l.kt)("inlineCode",{parentName:"p"},"Map"),". It is the ",(0,l.kt)("inlineCode",{parentName:"p"},"String")," that can be null in ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable String[]")," and it is\nthe ",(0,l.kt)("inlineCode",{parentName:"p"},"[]"),", meaning the array, that can be null in ",(0,l.kt)("inlineCode",{parentName:"p"},"String @Nullable []"),"."),(0,l.kt)("h3",{id:"wildcard-bounds"},"Wildcard bounds"),(0,l.kt)("p",null,"Inside ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked"),", wildcard bounds work almost exactly the same as type\nvariable bounds. We saw that ",(0,l.kt)("inlineCode",{parentName:"p"},"<E extends @Nullable Number>")," means that E can be\na ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable")," type and ",(0,l.kt)("inlineCode",{parentName:"p"},"<E extends Number>")," means it can't. Likewise, ",(0,l.kt)("inlineCode",{parentName:"p"},"List<?\nextends @Nullable Number>")," means a list where the elements can be null, and\n",(0,l.kt)("inlineCode",{parentName:"p"},"List<? extends Number>")," means they can't."),(0,l.kt)("p",null,"However, there's a difference when there is no explicit bound. We saw that a\ntype variable definition like ",(0,l.kt)("inlineCode",{parentName:"p"},"<E>")," means ",(0,l.kt)("inlineCode",{parentName:"p"},"<E extends Object>")," and that means it\nis not ",(0,l.kt)("inlineCode",{parentName:"p"},"@Nullable"),". But ",(0,l.kt)("inlineCode",{parentName:"p"},"<?>")," actually means ",(0,l.kt)("inlineCode",{parentName:"p"},"<? extends B>"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"B")," is the\nbound of the corresponding type variable. So if we have"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"interface List<E extends @Nullable Object> {...}\n")),(0,l.kt)("p",null,"then ",(0,l.kt)("inlineCode",{parentName:"p"},"List<?>")," means the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"List<? extends @Nullable Object>"),". If we have"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class ImmutableList<E> implements List<E> {...}\n")),(0,l.kt)("p",null,"then we saw that that means the same as"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class ImmutableList<E extends Object> implements List<E>\n")),(0,l.kt)("p",null,"so ",(0,l.kt)("inlineCode",{parentName:"p"},"ImmutableList<?>")," means the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"ImmutableList<? extends Object>"),". And\nhere, ",(0,l.kt)("inlineCode",{parentName:"p"},"@NullMarked")," means that ",(0,l.kt)("inlineCode",{parentName:"p"},"Object")," excludes null. The ",(0,l.kt)("inlineCode",{parentName:"p"},"get(int)")," method of\n",(0,l.kt)("inlineCode",{parentName:"p"},"List<?>")," can return null but the same method of ",(0,l.kt)("inlineCode",{parentName:"p"},"ImmutableList<?>")," can't."))}d.isMDXComponent=!0}}]);