"use strict";(self.webpackChunkjspecify=self.webpackChunkjspecify||[]).push([[805],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=s(n),h=i,c=d["".concat(p,".").concat(h)]||d[h]||m[h]||o;return n?a.createElement(c,l(l({ref:t},u),{},{components:n})):a.createElement(c,l({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=d;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var s=2;s<o;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7985:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const o={title:"Nullness Specification (draft)"},l="Nullness Specification (draft)",r={unversionedId:"spec",id:"spec",title:"Nullness Specification (draft)",description:"This document is a draft specification for the precise semantics of our set of",source:"@site/docs/spec.md",sourceDirName:".",slug:"/spec",permalink:"/docs/spec",draft:!1,editUrl:"https://github.com/jspecify/jspecify/tree/main/docs/docs/spec.md",tags:[],version:"current",frontMatter:{title:"Nullness Specification (draft)"},sidebar:"tutorialSidebar",previous:{title:"Nullness User Guide (draft)",permalink:"/docs/user-guide"}},p={},s=[{value:"The word &quot;nullable&quot;",id:"the-word-nullable",level:3},{value:"The scope of this spec",id:"the-scope-of-this-spec",level:3},{value:"That&#39;s all!",id:"thats-all",level:3},{value:"Normative and non-normative sections",id:"normative-and-non-normative-sections",level:2},{value:"Relationship between this spec and JLS",id:"concept-references",level:2},{value:"Base type",id:"base-type",level:2},{value:"Type components",id:"type-components",level:2},{value:"Nullness operator",id:"nullness-operator",level:2},{value:"Augmented type",id:"augmented-type",level:2},{value:"Details common to all annotations",id:"details-common-to-all-annotations",level:2},{value:"The type-use annotation",id:"the-type-use-annotation",level:2},{value:"Recognized locations for type-use annotations",id:"recognized-locations-for-type-use-annotations",level:3},{value:"The declaration annotation",id:"the-declaration-annotation",level:2},{value:"Recognized locations for declaration annotations",id:"recognized-locations-for-declaration-annotations",level:3},{value:"Null-marked scope",id:"null-marked-scope",level:2},{value:"Augmented type of a type usage appearing in code",id:"augmented-type-of-usage",level:2},{value:"Augmented type of an intersection type",id:"intersection-types",level:2},{value:"Bound of an &quot;unbounded&quot; wildcard",id:"unbounded-wildcard",level:2},{value:"Bound of an <code>Object</code>-bounded type parameter",id:"object-bounded-type-parameter",level:2},{value:"Augmented null types",id:"null-types",level:2},{value:"Multiple &quot;worlds&quot;",id:"multiple-worlds",level:2},{value:"Propagating how many worlds a relation must hold in",id:"propagating-multiple-worlds",level:3},{value:"Same type",id:"same-type",level:2},{value:"Subtyping",id:"subtyping",level:2},{value:"Nullness subtyping",id:"nullness-subtyping",level:2},{value:"Null-inclusive under every parameterization",id:"null-inclusive-under-every-parameterization",level:2},{value:"Null-exclusive under every parameterization",id:"null-exclusive-under-every-parameterization",level:2},{value:"Nullness-subtype-establishing path",id:"nullness-subtype-establishing-path",level:2},{value:"Nullness-subtype-establishing direct-supertype edges",id:"nullness-subtype-establishing-direct-supertype-edges",level:2},{value:"Nullness-delegating subtyping rules for Java",id:"nullness-delegating-subtyping",level:2},{value:"Containment",id:"containment",level:2},{value:"Substitution",id:"substitution",level:2},{value:"Applying a nullness operator to an augmented type",id:"applying-operator",level:2},{value:"Capture conversion",id:"capture-conversion",level:2}],u={toc:s};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"nullness-specification-draft"},"Nullness Specification (draft)"),(0,i.kt)("p",null,"This document is a draft specification for the precise semantics of our set of\nannotations for nullness analysis."),(0,i.kt)("admonition",{title:"Advice to readers (non-normative)",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The primary audience for this document is the authors of analysis tools. Some\nvery advanced users might find it interesting. But it would make a very poor\nintroduction for anyone else; instead see our ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/start-here"},"Start Here")," page"),".")),(0,i.kt)("admonition",{title:"Status of this specification",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This document is current as of JSpecify ",(0,i.kt)("strong",{parentName:"p"},"0.2.0"),", but does not reflect several\ndesign changes between then and ",(0,i.kt)("strong",{parentName:"p"},"0.3.0"),".")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"the-word-nullable"},'The word "nullable"'),(0,i.kt)("p",null,'In this doc, we aim not to refer to whether a type "is nullable." Instead, we\ndraw some distinctions, creating at least four kinds of "Is it nullable?"\nquestions we can ask for any given type usage:'),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Does ",(0,i.kt)("inlineCode",{parentName:"li"},"@Nullable")," appear directly on that type usage?"),(0,i.kt)("li",{parentName:"ol"},"What is the ",(0,i.kt)("a",{parentName:"li",href:"#nullness-operator"},"nullness operator")," of that type usage?"),(0,i.kt)("li",{parentName:"ol"},"Is it reasonable to assume that ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),' won\'t come "out" of it?'),(0,i.kt)("li",{parentName:"ol"},"Is it reasonable to assume that ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),' can\'t be put "in" to it?')),(0,i.kt)("h3",{id:"the-scope-of-this-spec"},"The scope of this spec"),(0,i.kt)("p",null,"Currently, this spec does not address ",(0,i.kt)("em",{parentName:"p"},"when")," tools must apply any part of the\nspec. For example, it does not state when tools must check that the ",(0,i.kt)("a",{parentName:"p",href:"#subtyping"},"subtyping"),"\nrelation holds."),(0,i.kt)("p",null,"We anticipate that tools will typically apply parts of this spec in the same\ncases that they (or ",(0,i.kt)("inlineCode",{parentName:"p"},"javac"),") already apply the corresponding parts of the Java\nLanguage Specification. For example, if code contains the parameterized type\n",(0,i.kt)("inlineCode",{parentName:"p"},"List<@Nullable Foo>"),", we anticipate that tools will check that ",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable Foo"),"\nis a subtype of the bound of the type parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),"."),(0,i.kt)("p",null,"However, this is up to tool authors, who may have reasons to take a different\napproach. For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Java ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/49"},"places some restrictions that aren't necessary for soundness"),",\nand it ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/65"},"is lenient in at least one way that can lead to runtime\nerrors"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'JSpecify annotations can be used even by tools that are not "nullness\ncheckers" at all. For example, a tool that lists the members of an API could\nshow the nullness of each type in the API, without any checking that those\ntypes are "correct."')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'Even when a tool is a "nullness checker," it might be written for another\nlanguage, like Kotlin, with its own rules for when to perform type checks.\nOr the tool might target a future version of Java whose language features\nwould not be covered by this version of this spec.'))),(0,i.kt)("p",null,"Note also that this spec covers only nullness information ",(0,i.kt)("em",{parentName:"p"},"from JSpecify\nannotations"),". Tools may have additional sources of information. For example, a\ntool may recognize additional annotations. Or a tool may omit the concept of\n",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED")," and apply a policy that type usages like ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," are always\nnon-nullable."),(0,i.kt)("h3",{id:"thats-all"},"That's all!"),(0,i.kt)("p",null,"On to the spec."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"normative-and-non-normative-sections"},"Normative and non-normative sections"),(0,i.kt)("p",null,"This document contains some non-normative comments to emphasize points or to\nanticipate likely questions. Those comments are set off as block quotes."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This is an example of a non-normative comment.")),(0,i.kt)("p",null,"This document also links to other documents. Those documents are non-normative,\nexcept for when we link to the Java Language Specification to defer to its\nrules."),(0,i.kt)("h2",{id:"concept-references"},"Relationship between this spec and JLS"),(0,i.kt)("p",null,"When a rule in this spec refers to any concept that is defined in this spec (for\nexample, ",(0,i.kt)("a",{parentName:"p",href:"#substitution"},"substitution")," or ",(0,i.kt)("a",{parentName:"p",href:"#containment"},"containment"),"), apply this spec's definition (as\nopposed to other definitions, such as the ones in the Java Language\nSpecification (JLS))."),(0,i.kt)("p",null,"Additionally, when a rule in this spec refers to a JLS rule that in turn refers\nto a concept that is defined in this spec, likewise apply this spec's\ndefinition."),(0,i.kt)("p",null,"In particular, when a JLS rule refers to types, apply this spec's definition of\n",(0,i.kt)("a",{parentName:"p",href:"#augmented-type"},"augmented types")," ","(","as opposed to ",(0,i.kt)("a",{parentName:"p",href:"#base-type"},"base types"),")."),(0,i.kt)("h2",{id:"base-type"},"Base type"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"base type")," is a type as defined in ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html"},"JLS 4"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'JLS 4 does not consider a type-use annotation to be a part of the type it\nannotates, so neither does our concept of "base type."')),(0,i.kt)("h2",{id:"type-components"},"Type components"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"type component")," of a given type is a type that transitively forms some part\nof that type. Specifically, a type component is one of the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a non-wildcard type argument"),(0,i.kt)("li",{parentName:"ul"},"a wildcard bound"),(0,i.kt)("li",{parentName:"ul"},"an array component type"),(0,i.kt)("li",{parentName:"ul"},"an enclosing type"),(0,i.kt)("li",{parentName:"ul"},"an element of an intersection type"),(0,i.kt)("li",{parentName:"ul"},"the entire type")),(0,i.kt)("h2",{id:"nullness-operator"},"Nullness operator"),(0,i.kt)("p",null,"A nullness operator is one of 4 values:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"UNION_NULL")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NO_CHANGE")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"UNSPECIFIED")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MINUS_NULL"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The informal meaning of the operators is:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"UNION_NULL"),": This is the operator produced by putting ",(0,i.kt)("inlineCode",{parentName:"li"},"@Nullable")," on a\ntype usage.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The type usage ",(0,i.kt)("inlineCode",{parentName:"li"},"String UNION_NULL")," includes ",(0,i.kt)("inlineCode",{parentName:"li"},'"a"'),", ",(0,i.kt)("inlineCode",{parentName:"li"},'"b"'),", ",(0,i.kt)("inlineCode",{parentName:"li"},'"ab"'),",\netc., plus ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),"."),(0,i.kt)("li",{parentName:"ul"},"The type-variable usage ",(0,i.kt)("inlineCode",{parentName:"li"},"T UNION_NULL")," includes all members of ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),",\nplus ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," if it wasn't already included."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NO_CHANGE"),": This is the operator produced by ",(0,i.kt)("em",{parentName:"li"},"not")," putting ",(0,i.kt)("inlineCode",{parentName:"li"},"@Nullable")," on\na type usage (aside from the exception discussed under ",(0,i.kt)("inlineCode",{parentName:"li"},"UNSPECIFIED"),"\nbelow).",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The type usage ",(0,i.kt)("inlineCode",{parentName:"li"},"String NO_CHANGE")," includes ",(0,i.kt)("inlineCode",{parentName:"li"},'"a"'),", ",(0,i.kt)("inlineCode",{parentName:"li"},'"b"'),", ",(0,i.kt)("inlineCode",{parentName:"li"},'"ab"'),", etc.,\nwithout including ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),"."),(0,i.kt)("li",{parentName:"ul"},"The type-variable usage ",(0,i.kt)("inlineCode",{parentName:"li"},"T NO_CHANGE")," includes exactly the members of\n",(0,i.kt)("inlineCode",{parentName:"li"},"T"),": If ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," was a member of ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),", then it's a member of ",(0,i.kt)("inlineCode",{parentName:"li"},"T\nNO_CHANGE"),". If it was not a member of ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),", then it is not a member of\n",(0,i.kt)("inlineCode",{parentName:"li"},"T NO_CHANGE"),"."),(0,i.kt)("li",{parentName:"ul"},"One way to conceptualize this is that ",(0,i.kt)("inlineCode",{parentName:"li"},"String NO_CHANGE"),' means\n"non-null ',(0,i.kt)("inlineCode",{parentName:"li"},"String"),'" but that ',(0,i.kt)("inlineCode",{parentName:"li"},"T NO_CHANGE"),' means "nullness comes from\nthe value of ',(0,i.kt)("inlineCode",{parentName:"li"},"T"),'."'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"UNSPECIFIED"),": This is the operator produced by not putting ",(0,i.kt)("inlineCode",{parentName:"li"},"@Nullable")," on\na type usage ",(0,i.kt)("em",{parentName:"li"},"in code that is outside a ",(0,i.kt)("a",{parentName:"em",href:"#null-marked-scope"},"null-marked scope")),'. Roughly, it\nis the operator assigned to "completely unannotated code."',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The type usage ",(0,i.kt)("inlineCode",{parentName:"li"},"String UNSPECIFIED")," includes ",(0,i.kt)("inlineCode",{parentName:"li"},'"a"'),", ",(0,i.kt)("inlineCode",{parentName:"li"},'"b"'),", ",(0,i.kt)("inlineCode",{parentName:"li"},'"ab"'),",\netc., but whether ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," should be included is not specified."),(0,i.kt)("li",{parentName:"ul"},"The type-variable usage ",(0,i.kt)("inlineCode",{parentName:"li"},"T UNSPECIFIED")," includes all members of ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),".\nBut whether ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," should be added to the set (if it isn't already)\nis not specified."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MINUS_NULL"),": This operator not only does not ",(0,i.kt)("em",{parentName:"li"},"add")," ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," but also\nactively ",(0,i.kt)("em",{parentName:"li"},"removes")," it from a type-variable usage that might otherwise\ninclude it.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The type usage ",(0,i.kt)("inlineCode",{parentName:"li"},"String MINUS_NULL")," includes ",(0,i.kt)("inlineCode",{parentName:"li"},'"a"'),", ",(0,i.kt)("inlineCode",{parentName:"li"},'"b"'),", ",(0,i.kt)("inlineCode",{parentName:"li"},'"ab"'),",\netc., without including ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),". (This is equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"String\nNO_CHANGE"),".)"),(0,i.kt)("li",{parentName:"ul"},"The type-variable usage ",(0,i.kt)("inlineCode",{parentName:"li"},"T MINUS_NULL")," includes all members of ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),(0,i.kt)("em",{parentName:"li"},"except")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),". (This is equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"T NO_CHANGE")," unless\n",(0,i.kt)("inlineCode",{parentName:"li"},"null")," was a member of ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),".)"))))),(0,i.kt)("h2",{id:"augmented-type"},"Augmented type"),(0,i.kt)("p",null,"An augmented type consists of a ",(0,i.kt)("a",{parentName:"p",href:"#base-type"},"base type")," and a ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator"),"\ncorresponding to ",(0,i.kt)("em",{parentName:"p"},"each")," of its ",(0,i.kt)("a",{parentName:"p",href:"#type-components"},"type components"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Arguably, an augmented type with nullness operator ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),' is better\nunderstood not as representing "a type" but as representing a ',(0,i.kt)("em",{parentName:"p"},"lack")," of the\nnullness portion of the type.")),(0,i.kt)("p",null,"For our purposes, base types (and thus augmented types) include not just class\nand interface types, array types, and type variables but also\n",(0,i.kt)("a",{parentName:"p",href:"#intersection-types"},"intersection types")," and the null type."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This spec aims to define rules for augmented types compatible with those that\nthe JLS defines for base types."),(0,i.kt)("p",{parentName:"blockquote"},"Accordingly, in almost all cases, this spec agrees with the JLS's rules when\nspecifying what ",(0,i.kt)("em",{parentName:"p"},"base")," types appear in a piece of code. It makes an exception\nfor ",(0,i.kt)("a",{parentName:"p",href:"#unbounded-wildcard"},'"Bound of an unbounded wildcard,"')," for which it\nspecifies a bound of ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," that the JLS does not specify.")),(0,i.kt)("p",null,"When this spec uses capital letters, they refer to augmented types (unless\notherwise noted). This is in contrast to the JLS, which typically uses them to\nrefer to base types."),(0,i.kt)("p",null,'When this spec refers to "the nullness operator of" a type ',(0,i.kt)("inlineCode",{parentName:"p"},"T"),", it refers\nspecifically to the nullness operator of the type component that is the entire\ntype ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", without reference to the nullness operator of any other type that is\na component of ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," or has ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," as a component."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'For example, "the nullness operator of ',(0,i.kt)("inlineCode",{parentName:"p"},"List<Object>"),'" refers to whether the\nlist itself may be ',(0,i.kt)("inlineCode",{parentName:"p"},"null"),", not whether its elements may be.")),(0,i.kt)("h2",{id:"details-common-to-all-annotations"},"Details common to all annotations"),(0,i.kt)("p",null,"For all named annotations referred to by this spec:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The package name is ",(0,i.kt)("inlineCode",{parentName:"li"},"org.jspecify.nullness"),". ","[","[#260]","]"),(0,i.kt)("li",{parentName:"ul"},"The Java module name is ",(0,i.kt)("inlineCode",{parentName:"li"},"org.jspecify"),". ","[",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jspecify/jspecify/issues/181"},"#181"),"]"),(0,i.kt)("li",{parentName:"ul"},"The Maven artifact is ",(0,i.kt)("inlineCode",{parentName:"li"},"org.jspecify:jspecify"),". ","[",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jspecify/jspecify/issues/181"},"#181"),"]")),(0,i.kt)("p",null,"All annotations have runtime retention. ","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/28"},"#28"),"]"," None of the annotations are\nmarked ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/annotation/Repeatable.html"},"repeatable"),"."),(0,i.kt)("h2",{id:"the-type-use-annotation"},"The type-use annotation"),(0,i.kt)("p",null,"We provide a parameterless type-use annotation called ",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable"),"."),(0,i.kt)("h3",{id:"recognized-locations-for-type-use-annotations"},"Recognized locations for type-use annotations"),(0,i.kt)("p",null,"A location is a ",(0,i.kt)("em",{parentName:"p"},"recognized")," location for our type-use annotation in the\ncircumstances detailed below. This spec does not define semantics for\nannotations in other locations."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"For now, we've chosen to restrict ourselves to API locations for which tools\nmostly agree on what it means for a type in that location to be ",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable"),"."),(0,i.kt)("p",{parentName:"blockquote"},'When analyzing source code, tools are encouraged to offer an option to issue\nan error for an annotation in an unrecognized location (unless they define\nsemantics for that location). Tools are especially encouraged to issue an\nerror for an annotation in a location that is "intrinsically non-nullable"\n(defined below).'),(0,i.kt)("p",{parentName:"blockquote"},"When reading ",(0,i.kt)("em",{parentName:"p"},"bytecode"),", however, tools may be best off ignoring an annotation\nin an unrecognized location (again, unless they define semantics for that\nlocation).")),(0,i.kt)("p",null,"The following locations are recognized except when overruled by one of the\nexceptions in the subsequent sections: ","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/17"},"#17"),"]"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"return type of a method")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"formal parameter type of a method or constructor, as defined in ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1"},"JLS 8.4.1")),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This excludes the receiver parameter."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"field type")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"type parameter upper bound ","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/60"},"#60"),"]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"non-wildcard type argument")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"wildcard bound")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"array component type")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"type used in a variadic parameter declaration"))),(0,i.kt)("p",null,"However, any location above is unrecognized if it matches either of the\nfollowing cases: ","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/17"},"#17"),"]"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'We refer to these cases (and some other cases below) as "intrinsically\nnon-nullable."')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"a type usage of a value type (currently, the 8 predefined primitive types)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the outer type that qualifies an inner type"),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"For example, the annotation in ",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable Foo.Bar")," is in an unrecognized\nlocation: Java syntax attaches it to the outer type ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo"),"."),(0,i.kt)("p",{parentName:"blockquote"},"(Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable Foo.Bar")," is a ",(0,i.kt)("em",{parentName:"p"},"Java")," syntax error when ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar")," is a\n",(0,i.kt)("em",{parentName:"p"},"static")," type. If ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar")," is a non-static type, then Java permits the code.\nSo JSpecify tools have the oppotunity to reject it, given that the author\nprobably intended ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo.@Nullable Bar"),".)")),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"Every outer type is intrinsically non-nullable because every instance of\nan inner class has an associated instance of the outer class.")))),(0,i.kt)("p",null,"Additionally, any location above is unrecognized if it makes up ",(0,i.kt)("em",{parentName:"p"},"any\n",(0,i.kt)("a",{parentName:"em",href:"#type-components"},"type component"))," of a type in the following locations: ","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/17"},"#17"),"]"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'These locations all fit under the umbrella of "implementation code."\nImplementation code may use types that contain type arguments, wildcard\nbounds, and array component types, which would be recognized locations if not\nfor the exceptions defined by this section.')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a local variable type"),(0,i.kt)("li",{parentName:"ul"},"an exception parameter"),(0,i.kt)("li",{parentName:"ul"},"the type in a cast or ",(0,i.kt)("inlineCode",{parentName:"li"},"instanceof")," expression"),(0,i.kt)("li",{parentName:"ul"},"an array or object creation expression (including via a member reference)"),(0,i.kt)("li",{parentName:"ul"},"an explicit type argument supplied to a generic method or constructor\n(including via a member reference) or to an instance creation expression for\na generic class")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In practice, we anticipate that tools will treat types (and their annotations)\nin ",(0,i.kt)("em",{parentName:"p"},"most")," of the above locations much like they treat types in other\nlocations. Still, this spec does not concern itself with implementation code:\nWe believe that the most important domain for us to focus on is that of APIs.")),(0,i.kt)("p",null,"All locations that are not explicitly listed as recognized are unrecognized."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Other notable unrecognized annotations include: ","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/17"},"#17"),"]"),(0,i.kt)("p",{parentName:"blockquote"},"Some additional intrinsically non-nullable locations:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"supertype in a class declaration"),(0,i.kt)("li",{parentName:"ul"},"thrown exception type"),(0,i.kt)("li",{parentName:"ul"},"enum constant declaration"),(0,i.kt)("li",{parentName:"ul"},"receiver parameter type")),(0,i.kt)("p",{parentName:"blockquote"},"Some other locations that individual tools are more likely to assign semantics\nto:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"a class declaration ","[",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jspecify/jspecify/issues/7"},"#7"),"]",": For example, the annotation in ",(0,i.kt)("inlineCode",{parentName:"li"},"public\n@Nullable class Foo {}")," is in an unrecognized location."),(0,i.kt)("li",{parentName:"ul"},"a type-parameter declaration or a wildcard ",(0,i.kt)("em",{parentName:"li"},"itself")," ","[",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jspecify/jspecify/issues/19"},"#19"),", ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jspecify/jspecify/issues/31"},"#31"),"]"),(0,i.kt)("li",{parentName:"ul"},"any ",(0,i.kt)("a",{parentName:"li",href:"#type-components"},"type component")," of a receiver parameter type ","[",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jspecify/jspecify/issues/157"},"#157"),"]")),(0,i.kt)("p",{parentName:"blockquote"},'But note that types "inside" some of these locations can still be recognized,\nsuch as a ',(0,i.kt)("em",{parentName:"p"},"type argument")," of a supertype.")),(0,i.kt)("h2",{id:"the-declaration-annotation"},"The declaration annotation"),(0,i.kt)("p",null,"We provide a single parameterless declaration annotation called ",(0,i.kt)("inlineCode",{parentName:"p"},"@NullMarked"),".\n","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/5"},"#5"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/87"},"#87"),"]"),(0,i.kt)("h3",{id:"recognized-locations-for-declaration-annotations"},"Recognized locations for declaration annotations"),(0,i.kt)("p",null,"Our declaration annotation is specified to be ",(0,i.kt)("em",{parentName:"p"},"recognized")," when applied to the\nlocations listed below:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("em",{parentName:"li"},"named")," class."),(0,i.kt)("li",{parentName:"ul"},"A package. ","[",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jspecify/jspecify/issues/34"},"#34"),"]"),(0,i.kt)("li",{parentName:"ul"},"A module. ","[",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jspecify/jspecify/issues/34"},"#34"),"]")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("em",{parentName:"p"},"Not")," a method ","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/43"},"#43"),"]",", constructor ","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/43"},"#43"),"]",", or field ","[",(0,i.kt)("a",{parentName:"p",href:"https://github.com/jspecify/jspecify/issues/50"},"#50"),"]",".")),(0,i.kt)("h2",{id:"null-marked-scope"},"Null-marked scope"),(0,i.kt)("p",null,"To determine whether a type usage appears in a null-marked scope:"),(0,i.kt)("p",null,"Look for a ",(0,i.kt)("inlineCode",{parentName:"p"},"@NullMarked")," annotation on any of the scopes\nenclosing the type usage."),(0,i.kt)("p",null,"Class members are enclosed by classes, which may be enclosed by other class\nmembers or classes. and top-level classes are enclosed by packages, which may be\nenclosed by modules."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Packages are ",(0,i.kt)("em",{parentName:"p"},"not"),' enclosed by "parent" packages.')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'This definition of "enclosing" likely matches\n',(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/en/java/javase/14/docs/api/java.compiler/javax/lang/model/element/Element.html#getEnclosingElement()"},"the definition in the Java compiler API"),".")),(0,i.kt)("p",null,"If one of those scopes is directly annotated with\n",(0,i.kt)("inlineCode",{parentName:"p"},"@NullMarked"),", then the type usage is in a null-marked\nscope. Otherwise, it is not."),(0,i.kt)("h2",{id:"augmented-type-of-usage"},"Augmented type of a type usage appearing in code"),(0,i.kt)("p",null,"For most type usages in source code or bytecode on which JSpecify nullness\nannotations are ",(0,i.kt)("a",{parentName:"p",href:"#recognized-locations-for-type-use-annotations"},"recognized"),", this section defines how to determine their\n",(0,i.kt)("a",{parentName:"p",href:"#augmented-type"},"augmented types"),". Note, however, that rules for specific cases below take\nprecedence over the general rule here."),(0,i.kt)("p",null,"Because the JLS already has rules for determining the ",(0,i.kt)("a",{parentName:"p",href:"#base-type"},"base type")," for a type\nusage, this section covers only how to determine its ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator"),"."),(0,i.kt)("p",null,"To determine the nullness operator, apply the following rules in order. Once one\ncondition is met, skip the remaining conditions."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the type usage is annotated with ",(0,i.kt)("inlineCode",{parentName:"li"},"@Nullable"),", its\nnullness operator is ",(0,i.kt)("inlineCode",{parentName:"li"},"UNION_NULL"),"."),(0,i.kt)("li",{parentName:"ul"},"If the type usage appears in a ",(0,i.kt)("a",{parentName:"li",href:"#null-marked-scope"},"null-marked scope"),", its nullness operator is\n",(0,i.kt)("inlineCode",{parentName:"li"},"NO_CHANGE"),"."),(0,i.kt)("li",{parentName:"ul"},"Its nullness operator is ",(0,i.kt)("inlineCode",{parentName:"li"},"UNSPECIFIED"),".")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The choice of nullness operator is ",(0,i.kt)("em",{parentName:"p"},"not")," affected by any nullness operator\nthat appears in a corresponding location in a supertype. For example, if one\ntype declares a method whose return type is annotated ",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable"),", and if\nanother type overrides that method but does not declare the return type as\n",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable"),", then the override's return type will ",(0,i.kt)("em",{parentName:"p"},"not")," have nullness operator\n",(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL"),".")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The rules here never produce the fourth nullness operator, ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),".\nHowever, if tool authors prefer, they can safely produce ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL")," in any\ncase in which it is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),". For example, there is no\ndifference between ",(0,i.kt)("inlineCode",{parentName:"p"},"String NO_CHANGE")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"String MINUS_NULL"),".")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"So why does ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL")," exist at all? It does appear later in this spec in\nthe section on ",(0,i.kt)("a",{parentName:"p",href:"#substitution"},"substitution"),". However, its main purpose is to provide tools\nwith a way to represent the nullness of certain expressions in implementation\ncode: Consider ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList<E>"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," supports null elements, so the\nclass has to handle the possibility that any expression of type ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," may be\nnull. However, if implementation code contains the statement ",(0,i.kt)("inlineCode",{parentName:"p"},"if (e != null) {\n... }"),", then tools can assume that ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," is non-null inside. The purpose of\n",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL")," is to represent that such an expression is known not to be null,\neven though its base type ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," suggests otherwise.")),(0,i.kt)("h2",{id:"intersection-types"},"Augmented type of an intersection type"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Technically speaking, the JLS does not define syntax for an intersection type.\nInstead, it defines a syntax for type parameters and casts that supports\nmultiple types. Then the intersection type is derived from those. Intersection\ntypes can also arise from operations like ",(0,i.kt)("a",{parentName:"p",href:"#capture-conversion"},"capture conversion"),". See ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.9"},"JLS 4.9"),"."),(0,i.kt)("p",{parentName:"blockquote"},'One result of this is that it\'s never possible for a programmer to write an\nannotation "on an intersection type."')),(0,i.kt)("p",null,"This spec assigns a ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," to each individual element of an\nintersection type, following our normal rules for type usages. It also assigns a\nnullness operator to the intersection type as a whole. The nullness operator of\nthe type as a whole is always ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This lets us provide, for every ",(0,i.kt)("a",{parentName:"p",href:"#base-type"},"base type"),", a rule for computing its\n",(0,i.kt)("a",{parentName:"p",href:"#augmented-type"},"augmented type"),". But we require ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),' so as to avoid questions like\nwhether "a ',(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL")," intersection type whose members are ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo UNION_NULL"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar UNION_NULL"),'" is a subtype of "a ',(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),' intersection type with\nthose same members." Plus, it would be difficult for tools to output the\nnullness operator of an intersection type in a human-readable way.')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"To avoid ever creating an intersection type with a nullness operator other\nthan ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),", we define special handling for intersection types under\n",(0,i.kt)("a",{parentName:"p",href:"#applying-operator"},'"Applying a nullness operator to an augmented type."'))),(0,i.kt)("h2",{id:"unbounded-wildcard"},'Bound of an "unbounded" wildcard'),(0,i.kt)("p",null,"In source, an unbounded wildcard is written as ",(0,i.kt)("inlineCode",{parentName:"p"},"<?>"),". This section does ",(0,i.kt)("em",{parentName:"p"},"not"),"\napply to ",(0,i.kt)("inlineCode",{parentName:"p"},"<? extends Object>"),", even though that is often equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"<?>"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"See ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1"},"JLS 4.5.1"),".")),(0,i.kt)("p",null,"In bytecode, such a wildcard is represented as a wildcard type with an empty\nlist of upper bounds and an empty list of lower bounds. This section does ",(0,i.kt)("em",{parentName:"p"},"not"),"\napply to a wildcard with any bounds in either list, even a sole upper bound of\n",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"For a wildcard with an explicit bound of ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," (that is, ",(0,i.kt)("inlineCode",{parentName:"p"},"<? extends\nObject>"),", perhaps with an annotation on ",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),"), instead apply\n",(0,i.kt)("a",{parentName:"p",href:"#augmented-type-of-usage"},"the normal rules")," for the explicit bound type.")),(0,i.kt)("p",null,"If an unbounded wildcard appears in a ",(0,i.kt)("a",{parentName:"p",href:"#null-marked-scope"},"null-marked scope"),", then it has a single\nupper bound whose ",(0,i.kt)("a",{parentName:"p",href:"#base-type"},"base type")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," and whose ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL"),"."),(0,i.kt)("p",null,"If an unbounded wildcard appears outside a null-marked scope, then it has a\nsingle upper bound whose base type is ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," and whose nullness operator is\n",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In both cases, we specify a bound that does not exist in the source or\nbytecode, deviating from the JLS. Because the base type of the bound is\n",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),", this should produce no user-visible differences except to tools that\nimplement JSpecify nullness analysis.")),(0,i.kt)("p",null,"Whenever a JLS rule refers specifically to ",(0,i.kt)("inlineCode",{parentName:"p"},"<?>"),", disregard it, and instead\napply the rules for ",(0,i.kt)("inlineCode",{parentName:"p"},"<? extends T>"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," has a base type of ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," and\nthe nullness operator defined by this section."),(0,i.kt)("h2",{id:"object-bounded-type-parameter"},"Bound of an ",(0,i.kt)("inlineCode",{parentName:"h2"},"Object"),"-bounded type parameter"),(0,i.kt)("p",null,"In source, an ",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),"-bounded type parameter can be writen in either of 2 ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<T>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<T extends Object>")," with no JSpecify nullness type annotations on the bound")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"See ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4"},"JLS 4.4"),".")),(0,i.kt)("p",null,"In bytecode, ",(0,i.kt)("inlineCode",{parentName:"p"},"<T>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<T extends Object>")," are both represented as a type\nparameter with a single upper bound, ",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),", and no JSpecify nullness type\nannotations on the bound."),(0,i.kt)("p",null,"If an ",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),"-bounded type parameter appears in a ",(0,i.kt)("a",{parentName:"p",href:"#null-marked-scope"},"null-marked scope"),", then its\nbound has a ",(0,i.kt)("a",{parentName:"p",href:"#base-type"},"base type")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," and a ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that this gives ",(0,i.kt)("inlineCode",{parentName:"p"},"<T>")," a different bound than ",(0,i.kt)("inlineCode",{parentName:"p"},"<?>")," (though only in a\nnull-marked scope).")),(0,i.kt)("p",null,"If an ",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),"-bounded type parameter appears outside a null-marked scope, then\nits bound has a base type of ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," and a nullness operator of ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"All these rules match the behavior of\n",(0,i.kt)("a",{parentName:"p",href:"#augmented-type-of-usage"},"our normal rules")," for determining the\n",(0,i.kt)("a",{parentName:"p",href:"#augmented-type"},"augmented type")," of the bound ",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),'. The only "special" part is that we\nconsider the source code ',(0,i.kt)("inlineCode",{parentName:"p"},"<T>")," to have a bound of ",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),", just as it does\nwhen compiled to bytecode.")),(0,i.kt)("h2",{id:"null-types"},"Augmented null types"),(0,i.kt)("p",null,'The JLS refers to "the null type." In this spec, we assign a ',(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator"),"\nto all types, including the null type. This produces multiple null types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the null ",(0,i.kt)("a",{parentName:"p",href:"#base-type"},"base type")," with nullness operator ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),': the\n"bottom"/"nothing" type used in ',(0,i.kt)("a",{parentName:"p",href:"#capture-conversion"},"capture conversion")),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"No value has this type, not even ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," itself."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the null base type with nullness operator ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL")),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This is equivalent to the previous type. Tools may use the 2\ninterchangeably."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the null base type with nullness operator ",(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL"),": the type of the null\nreference")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the null base type with nullness operator ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED")),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This may be relevant only in implementation code.")))),(0,i.kt)("h2",{id:"multiple-worlds"},'Multiple "worlds"'),(0,i.kt)("p",null,'Some of the rules in this spec come in 2 versions: One version requires a\nproperty to hold "in all worlds," and the other requires it to hold only "in\nsome world."'),(0,i.kt)("p",null,"Tool authors may choose to implement neither, either, or both versions of the\nrules."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Our goal is to allow tools and their users to choose their desired level of\nstrictness in the presence of ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),". The basic idea is that, every\ntime a tool encounters a type component with the nullness operator\n",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),', it has the option to fork off 2 "worlds": 1 in which the\noperator is ',(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL")," and 1 in which it is ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),"."),(0,i.kt)("p",{parentName:"blockquote"},'In more detail: When tools lack a nullness specification for a type, they may\nchoose to assume that either of the resulting worlds may be the "correct"\nspecification. The all-worlds version of a rule, by requiring types to be\ncompatible in all possible worlds, holds that types are incompatible unless it\nhas enough information to prove they are compatible. The some-world version,\nby requiring types to be compatible only in ',(0,i.kt)("em",{parentName:"p"},"some"),' world, holds that types are\ncompatible unless it has enough information to prove they are incompatible.\n(By behaving "optimistically," the some-world version is much like Kotlin\'s\nrules for "platform types.")'),(0,i.kt)("p",{parentName:"blockquote"},"Thus, a strict tool might choose to implement the all-worlds version of rules,\nand a lenient tool might choose to implement the some-world version. Yet\nanother tool might implement both and let users select which rules to apply."),(0,i.kt)("p",{parentName:"blockquote"},'Still another possibility is for a tool to implement both versions and to use\nthat to distinguish between "errors" and "warnings." Such a tool might always\nfirst process code with the all-worlds version and then with the some-world\nversion. If the tools detects, say, an out-of-bounds type argument in both\ncases, the tool would produce an error. But, if the tool detects such a\nproblem with the all-worlds version but not with the some-world version, the\ntool would produce a warning. Under this scheme, a warning means roughly that\n"There is some way that the code could be annotated that would produce an\nerror here."')),(0,i.kt)("p",null,"The main body of each section of the spec describes the all-worlds rule. If the\nsome-world rule differs, the differences are explained at the end."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A small warning: To implement the full some-world rules, a tool must also\nimplement at least part of the all-worlds rules. Those rules are required as\npart of ",(0,i.kt)("a",{parentName:"p",href:"#substitution"},"substitution"),".")),(0,i.kt)("h3",{id:"propagating-multiple-worlds"},"Propagating how many worlds a relation must hold in"),(0,i.kt)("p",null,"When one rule in this spec refers to another, it refers to the same version of\nthe rule. For example, when the rules for ",(0,i.kt)("a",{parentName:"p",href:"#containment"},"containment")," refer to the rules for\n",(0,i.kt)("a",{parentName:"p",href:"#subtyping"},"subtyping"),", the some-world containment relation refers to the some-world\nsubtyping relation, and the all-worlds containment relation refers to the\nall-worlds subtyping relation."),(0,i.kt)("p",null,"This meta-rule applies except when a rule refers explicitly to a particular\nversion of another rule."),(0,i.kt)("h2",{id:"same-type"},"Same type"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"S")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," are the same type if ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," is a ",(0,i.kt)("a",{parentName:"p",href:"#subtyping"},"subtype")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is a subtype\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"."),(0,i.kt)("p",null,"The same-type relation is ",(0,i.kt)("em",{parentName:"p"},"not")," defined to be reflexive or transitive."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"For more discussion of reflexive and transitive relations, see the comments\nunder ",(0,i.kt)("a",{parentName:"p",href:"#nullness-subtyping"},"nullness subtyping"),".")),(0,i.kt)("h2",{id:"subtyping"},"Subtyping"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"A")," is a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," if both of the following conditions are met:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"A")," is a ",(0,i.kt)("a",{parentName:"li",href:"#nullness-subtyping"},"nullness subtype")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"F"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"A")," is a subtype of ",(0,i.kt)("inlineCode",{parentName:"li"},"F")," according to the\n",(0,i.kt)("a",{parentName:"li",href:"#nullness-delegating-subtyping"},"nullness-delegating subtyping rules for Java"),".")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'The first condition suffices for most cases. The second condition is necessary\nonly for types that have subcomponents --- namely, parameterized types and\narrays. And it essentially says "Check the first condition on subcomponents as\nappropriate."')),(0,i.kt)("h2",{id:"nullness-subtyping"},"Nullness subtyping"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"A")," is a nullness subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," if any of the following conditions are met:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Nullness subtyping asks the question: If ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," includes ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", does ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," also\ninclude ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"? There are 4 cases in which this is true, 2 easy and 2 hard:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"F")," is ",(0,i.kt)("a",{parentName:"p",href:"#null-inclusive-under-every-parameterization"},"null-inclusive under every parameterization"),"."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This is the first easy case: ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," always includes ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"A")," is ",(0,i.kt)("a",{parentName:"p",href:"#null-exclusive-under-every-parameterization"},"null-exclusive under every parameterization"),"."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This is the second easy case: ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," never includes ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"A")," has a ",(0,i.kt)("a",{parentName:"p",href:"#nullness-subtype-establishing-path"},"nullness-subtype-establishing path")," to any type whose base type\nis the same as the base type of ",(0,i.kt)("inlineCode",{parentName:"p"},"F"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," does ",(0,i.kt)("em",{parentName:"p"},"not")," have\n",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),"."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This is the first hard case: A given type-variable usage does not\nnecessarily always include ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", nor does it necessarily always exclude\n",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". (For example, consider a usage of ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," inside ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList<E>"),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," may be instantiated as either an ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList<@Nullable String>"),"\nor an ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList<String>"),".)"),(0,i.kt)("p",{parentName:"blockquote"},"Subtyping questions for type-variable usages are more complex: ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," is a\nnullness subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),"; ",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable E")," is not. Similarly, if ",(0,i.kt)("inlineCode",{parentName:"p"},"<F extends\nE>"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," is a nullness subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"E"),". But if ",(0,i.kt)("inlineCode",{parentName:"p"},"<F extends @Nullable\nE>"),", it is not."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"F")," is a type-variable usage that meets ",(0,i.kt)("em",{parentName:"p"},"both")," of the following conditions:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It does ",(0,i.kt)("em",{parentName:"p"},"not")," have nullness operator ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"A")," is a nullness subtype of its lower bound."))),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This is the second hard case: It covers type variables that are introduced\nby capture conversion of ",(0,i.kt)("inlineCode",{parentName:"p"},"? super")," wildcards."),(0,i.kt)("p",{parentName:"blockquote"},"In short, whether you have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate<? super String>"),", a ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate<?\nsuper @Nullable String>"),", or unannotated code that doesn't specify the\nnullness operator for the bound, you can always pass its ",(0,i.kt)("inlineCode",{parentName:"p"},"test")," method a\n",(0,i.kt)("inlineCode",{parentName:"p"},"String"),". (If you want to pass a ",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable String"),", then you'll need for\nthe bound to be ",(0,i.kt)("a",{parentName:"p",href:"#null-inclusive-under-every-parameterization"},"null-inclusive under every parameterization"),". The\nexistence of the null-inclusiveness rule frees this current rule from\nhaving to cover that case.)")))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A further level of complexity in all this is ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),". For example, in\nthe ",(0,i.kt)("a",{parentName:"p",href:"#multiple-worlds"},"all-worlds")," version of the following rules, a type with nullness operator\n",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED")," can be both null-",(0,i.kt)("em",{parentName:"p"},"inclusive")," under every parameterization and\nnull-",(0,i.kt)("em",{parentName:"p"},"exclusive")," under every parameterization.")),(0,i.kt)("p",null,"Nullness subtyping (and thus subtyping itself) is ",(0,i.kt)("em",{parentName:"p"},"not")," defined to be reflexive\nor transitive."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If we defined nullness subtyping to be reflexive, then ",(0,i.kt)("inlineCode",{parentName:"p"},"String UNSPECIFIED"),"\nwould be a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"String UNSPECIFIED"),", even under the ",(0,i.kt)("a",{parentName:"p",href:"#multiple-worlds"},"all-worlds")," rules.\nIn other words, we'd be saying that unannotated code is always free from\nnullness errors. That is clearly false. (Nevertheless, lenient tools will\nchoose not to issue errors for such code. They can do this by implementing the\n",(0,i.kt)("a",{parentName:"p",href:"#multiple-worlds"},"some-world")," rules.)"),(0,i.kt)("p",{parentName:"blockquote"},"If we defined nullness subtyping to be transitive, then ",(0,i.kt)("inlineCode",{parentName:"p"},"String UNION_NULL"),"\nwould be a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"String NO_CHANGE")," under the some-world rules. That\nwould happen because of a chain of subtyping rules:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"String UNION_NULL")," is a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"String UNSPECIFIED"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"String UNSPECIFIED")," is a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"String NO_CHANGE"),"."))),(0,i.kt)("p",{parentName:"blockquote"},"Therefore, ",(0,i.kt)("inlineCode",{parentName:"p"},"String UNION_NULL")," is a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"String NO_CHANGE"),"."),(0,i.kt)("p",{parentName:"blockquote"},'Yes, it\'s pretty terrible for something called "subtyping" not to be reflexive\nor transitive. A more accurate name for this concept would be "consistent," a\nterm used in gradual typing. However, we use "subtyping" anyway. In our\ndefense, we need to name multiple concepts, including not just subtyping but\nalso the ',(0,i.kt)("a",{parentName:"p",href:"#same-type"},"same-type")," relation and ",(0,i.kt)("a",{parentName:"p",href:"#containment"},"containment"),'. If we were to coin a new term\nfor each, tool authors would need to mentally map between those terms and the\nanalogous Java terms. (Still, yes: Feel free to read terms like "subtyping" as\nif they hvae scare quotes around them.)'),(0,i.kt)("p",{parentName:"blockquote"},"Subtyping does end up being transitive when the relation is required to hold\nin all worlds. And it does end up being reflexive when the relation is\nrequired to hold only in ",(0,i.kt)("a",{parentName:"p",href:"#multiple-worlds"},"some world"),". We don't state those properties as\nrules for 2 reasons: First, they arise naturally from the definitions. Second,\nwe don't want to suggest that subtyping is reflexive and transitive under both\nversions of the rule.")),(0,i.kt)("p",null,"Contrast this with our ",(0,i.kt)("a",{parentName:"p",href:"#nullness-delegating-subtyping"},"nullness-delegating subtyping")," rules and ",(0,i.kt)("a",{parentName:"p",href:"#containment"},"containment"),"\nrules: Each of those is defined as a transitive closure. However, this is\nincorrect, and we should fix it: Transitivity causes the same problem there as\nit does here: ",(0,i.kt)("inlineCode",{parentName:"p"},"List<? extends @Nullable String>")," ends up as a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"List<?\nextends String>")," because of a chain of subtyping rules that uses ",(0,i.kt)("inlineCode",{parentName:"p"},"String\nUNSPECIFIED"),' as part of the intermediate step. Luckily, tool authors that set\nout to implement transitivity for these two rules are very unlikely to write\ncode that "notices" this chain. So, in practice, users are likely to see the\n"mostly transitive" behavior that we intend, even if we haven\'t found a way to\nformally specify it yet.'),(0,i.kt)("h2",{id:"null-inclusive-under-every-parameterization"},"Null-inclusive under every parameterization"),(0,i.kt)("p",null,"A type is null-inclusive under every parameterization if it meets any of the\nfollowing conditions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Its ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL"),"."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This is the simplest part of the simplest case: A type usage always\nincludes ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," if it's annotated with ",(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It is an ",(0,i.kt)("a",{parentName:"p",href:"#intersection-types"},"intersection type")," whose elements all are null-inclusive under\nevery parameterization.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It is a type variable that meets ",(0,i.kt)("em",{parentName:"p"},"both")," of the following conditions:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It does ",(0,i.kt)("em",{parentName:"p"},"not")," have nullness operator ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Its lower bound is null-inclusive under every parameterization."))),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This third case is probably irrelevant in practice: It covers ",(0,i.kt)("inlineCode",{parentName:"p"},"? super\n@Nullable Foo"),", which is already covered by the rules for\n",(0,i.kt)("a",{parentName:"p",href:"#nullness-subtyping"},"nullness subtyping"),". It's included here in case some tool has reason to\ncheck whether a type is null-inclusive under every parameterization\n",(0,i.kt)("em",{parentName:"p"},"outside")," of a check for nullness subtyping.")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Some-world version:"),' The rule is the same except that the requirement for\n"',(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL"),'" is loosened to "',(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),'."'),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'That is: It\'s possible that any type usage in unannotated code "ought to be"\nannotated with ',(0,i.kt)("inlineCode",{parentName:"p"},"@Nullable"),".")),(0,i.kt)("h2",{id:"null-exclusive-under-every-parameterization"},"Null-exclusive under every parameterization"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'This is a straightforward concept ("never includes ',(0,i.kt)("inlineCode",{parentName:"p"},"null"),"\"), but it's not as\nsimple to implement as the null-",(0,i.kt)("em",{parentName:"p"},"inclusive")," rule was. This null-",(0,i.kt)("em",{parentName:"p"},"exclusive"),"\nrule has to cover cases like ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," (where ",(0,i.kt)("inlineCode",{parentName:"p"},"<E extends Object>"),"), and\n",(0,i.kt)("inlineCode",{parentName:"p"},"E")," (where ",(0,i.kt)("inlineCode",{parentName:"p"},"<E extends @Nullable Object>")," but nearby code has performed a null\ncheck on the expression). The case of ",(0,i.kt)("inlineCode",{parentName:"p"},"<E extends Object>"),' is an example of\nwhy the following rule requires looking for a "path."')),(0,i.kt)("p",null,"A type is null-exclusive under every parameterization if it has a\n",(0,i.kt)("a",{parentName:"p",href:"#nullness-subtype-establishing-path"},"nullness-subtype-establishing path")," to either of the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"any type whose ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"any augmented class or array type"),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},'This rule refers specifically to a "class or array type," as distinct from\nother types like type variables and ',(0,i.kt)("a",{parentName:"p",href:"#intersection-types"},"intersection types"),".")))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"When code dereferences an expression, we anticipate that tools will check\nwhether the expression is null-exclusive under every parameterization.")),(0,i.kt)("h2",{id:"nullness-subtype-establishing-path"},"Nullness-subtype-establishing path"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that this definition is used both by the definition of\n",(0,i.kt)("a",{parentName:"p",href:"#null-inclusive-under-every-parameterization"},"null-inclusive under every parameterization")," and by the third condition in\nthe definition ",(0,i.kt)("a",{parentName:"p",href:"#nullness-subtyping"},"nullness subtyping"),' itself (the "type-variable case").')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"A")," has a nullness-subtype-establishing path to ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," if both of the following\nhold:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"A")," has ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"There is a path from ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," through\n",(0,i.kt)("a",{parentName:"p",href:"#nullness-subtype-establishing-direct-supertype-edges"},"nullness-subtype-establishing direct-supertype edges"),"."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"The path may be empty. That is, ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," has a nullness-subtype-establishing\npath to itself --- as long as it has one of the required nullness\noperators.")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Some-world version:"),' The rules are the same except that the requirement for\n"',(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),'" is loosened to "',(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),", or\n",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),'."'),(0,i.kt)("h2",{id:"nullness-subtype-establishing-direct-supertype-edges"},"Nullness-subtype-establishing direct-supertype edges"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'This section defines the supertypes for a given type --- but limited to those\nthat fill the gaps in our nullness checking of "top-level" types. For example,\nthere\'s no need for the rules to reflect that ',(0,i.kt)("inlineCode",{parentName:"p"},"String NO_CHANGE")," extends\n",(0,i.kt)("inlineCode",{parentName:"p"},"Object NO_CHANGE"),": If we've established that a type has a path to ",(0,i.kt)("inlineCode",{parentName:"p"},"String\nNO_CHANGE"),", then we already know that it's\n",(0,i.kt)("a",{parentName:"p",href:"#null-exclusive-under-every-parameterization"},"null-exclusive under every parameterization"),", based on the rules above, and\nthat's enough to prove subtyping. And if we ",(0,i.kt)("em",{parentName:"p"},"haven't")," established that, then\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"-",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," edge isn't going to change that."),(0,i.kt)("p",{parentName:"blockquote"},"Thus, the rules here are restricted to type variables and intersection types,\nwhose supertypes may have nullness annotations.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"T")," has nullness-subtype-establishing direct-supertype edges to the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"if ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is an augmented ",(0,i.kt)("a",{parentName:"p",href:"#intersection-types"},"intersection type"),": all the intersection type's\nelements whose ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"if ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is an augmented type variable: all the corresponding type parameter's\nupper bounds whose nullness operator is ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"otherwise: no nodes"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Some-world version:"),' The rules are the same except that the requirements for\n"',(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),'" are loosened to "',(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),", or\n",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),'."'),(0,i.kt)("h2",{id:"nullness-delegating-subtyping"},"Nullness-delegating subtyping rules for Java"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'Recall that this rule exists to handle subcomponents of types --- namely, type\narguments and array component types. It essentially says "Check nullness\nsubtyping for subcomponents as appropriate."')),(0,i.kt)("p",null,"The Java subtyping rules are defined in ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10"},"JLS 4.10"),". (Each rule takes a type as\ninput and produces zero or more direct supertypes as outputs.) We add to them as\nfollows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#concept-references"},"As always"),", interpret the Java rules as operating on\n",(0,i.kt)("a",{parentName:"p",href:"#augmented-type"},"augmented types"),", not ",(0,i.kt)("a",{parentName:"p",href:"#base-type"},"base types"),". This raises the question of ",(0,i.kt)("em",{parentName:"p"},"how")," to\nextend these particular rules to operate on augmented types. The answer has\ntwo parts:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The first part of the answer applies only to the nullness operator ",(0,i.kt)("em",{parentName:"p"},'"of\nthe type."')," (",(0,i.kt)("a",{parentName:"p",href:"#augmented-type"},"As always"),", this means the nullness\noperator of the type component that is the entire type.)"),(0,i.kt)("p",{parentName:"li"},"And the first part of the answer is: No matter what nullness operator\nthe input augmented type has, the rules still apply, and they still\nproduce the same direct supertypes."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"Thanks to that rule, the nullness operator of any ",(0,i.kt)("em",{parentName:"p"},"output")," type is\nnever read by the subtyping rules.")),(0,i.kt)("p",{parentName:"li"},"So, when computing output types, tools may produce them with ",(0,i.kt)("em",{parentName:"p"},"any"),"\nnullness operator."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"Essentially, this rule says that the top-level types do no matter:\nThey have already been checked by the ",(0,i.kt)("a",{parentName:"p",href:"#nullness-subtyping"},"nullness subtyping")," check."),(0,i.kt)("p",{parentName:"blockquote"},"For simplicity, we recommend producing a nullness operator of\n",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),": That operator is valid for all types, including\n",(0,i.kt)("a",{parentName:"p",href:"#intersection-types"},"intersection types"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The nullness operators of ",(0,i.kt)("em",{parentName:"p"},"subcomponents")," of the augmented types ",(0,i.kt)("em",{parentName:"p"},"do"),"\nmatter. For example, some Java rules produce subtypes only if\nsubcomponents meet certain requirements.\n",(0,i.kt)("a",{parentName:"p",href:"#concept-references"},"As always"),", check those requirements by applying\n",(0,i.kt)("em",{parentName:"p"},"this spec's")," definitions."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"Those definitions (like ",(0,i.kt)("a",{parentName:"p",href:"#containment"},"containment"),") refer back to definitions (like\n",(0,i.kt)("a",{parentName:"p",href:"#nullness-subtyping"},"nullness subtyping"),") that use the nullness operators of the\nsubcomponents in question."))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When the Java array rules require one type to be a ",(0,i.kt)("em",{parentName:"p"},"direct")," supertype of\nanother, consider the direct supertypes of ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," to be ",(0,i.kt)("em",{parentName:"p"},"every")," type that ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"\nis a ",(0,i.kt)("a",{parentName:"p",href:"#subtyping"},"subtype")," of."))),(0,i.kt)("h2",{id:"containment"},"Containment"),(0,i.kt)("p",null,"The Java rules are defined in ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1"},"JLS 4.5.1"),". We add to them as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Disregard the 2 rules that refer to a bare ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),". Instead, treat ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," like ",(0,i.kt)("inlineCode",{parentName:"p"},"?\nextends Object"),", where the ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," bound is\nspecified by ",(0,i.kt)("a",{parentName:"p",href:"#unbounded-wildcard"},'"Bound of an unbounded wildcard."')),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This is just a part of our universal rule to treat a bare ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," like ",(0,i.kt)("inlineCode",{parentName:"p"},"?\nextends Object"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The rule written specifically for ",(0,i.kt)("inlineCode",{parentName:"p"},"? extends Object")," applies only if the\nnullness operator of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," bound is ",(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When the JLS refers to the same type ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," on both sides of a rule, the rule\napplies if and only if this spec defines the 2 types to be the ",(0,i.kt)("a",{parentName:"p",href:"#same-type"},"same type"),"."))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Some-world version:"),' The rules are the same except that the requirement for\n"',(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL"),'" is loosened to "',(0,i.kt)("inlineCode",{parentName:"p"},"UNION_NULL")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),'."'),(0,i.kt)("h2",{id:"substitution"},"Substitution"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Substitution on Java base types barely requires an explanation: See ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jls/se14/html/jls-1.html#jls-1.3"},"JLS 1.3"),".\nSubstitution on ",(0,i.kt)("a",{parentName:"p",href:"#augmented-type"},"augmented types"),", however, is trickier: If ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.get")," returns\n",(0,i.kt)("inlineCode",{parentName:"p"},"V UNION_NULL"),", and if a user has a map whose value type is ",(0,i.kt)("inlineCode",{parentName:"p"},"String\nUNSPECIFIED"),", then what does its ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," method return? Naive substitution would\nproduce ",(0,i.kt)("inlineCode",{parentName:"p"},"String UNSPECIFIED UNION_NULL"),". To reduce that to a proper augmented\ntype with a single nullness operator, we define this process.")),(0,i.kt)("p",null,"To substitute each type argument ",(0,i.kt)("inlineCode",{parentName:"p"},"A\u1d62")," for each corresponding type parameter\n",(0,i.kt)("inlineCode",{parentName:"p"},"P\u1d62"),":"),(0,i.kt)("p",null,"For every type-variable usage ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," whose ",(0,i.kt)("a",{parentName:"p",href:"#base-type"},"base type")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"P\u1d62"),", replace ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," with\nthe result of the following operation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," is ",(0,i.kt)("a",{parentName:"p",href:"#null-exclusive-under-every-parameterization"},"null-exclusive under every parameterization")," in ",(0,i.kt)("a",{parentName:"p",href:"#multiple-worlds"},"all worlds"),",\nthen replace it with the result of ",(0,i.kt)("a",{parentName:"p",href:"#applying-operator"},"applying"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"A\u1d62"),"."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This is the one instance in which a rule specifically refers to the\n",(0,i.kt)("a",{parentName:"p",href:"#multiple-worlds"},"all-worlds")," version of another rule. Normally,\n",(0,i.kt)("a",{parentName:"p",href:"#propagating-multiple-worlds"},'a rule "propagates" its version to other rules'),".\nBut in this instance, the null-exclusivity rule (and all rules that it in\nturn applies) are the ",(0,i.kt)("a",{parentName:"p",href:"#multiple-worlds"},"all-worlds")," versions.")),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},'The purpose of this special case is to improve behavior in "the\n',(0,i.kt)("inlineCode",{parentName:"p"},"ImmutableList.Builder"),' case": Because ',(0,i.kt)("inlineCode",{parentName:"p"},"ImmutableList.Builder.add")," always\nthrows ",(0,i.kt)("inlineCode",{parentName:"p"},"NullPointerException")," for a null argument, we would like for\n",(0,i.kt)("inlineCode",{parentName:"p"},"add(null)")," to be a compile error, even under lenient tools.\nUnfortunately, without this special case, lenient tools could permit\n",(0,i.kt)("inlineCode",{parentName:"p"},"add(null)")," in unannotated code. For an example, read on."),(0,i.kt)("p",{parentName:"blockquote"},"Consider an unannotated user of ",(0,i.kt)("inlineCode",{parentName:"p"},"ImmutableList.Builder<Foo> builder"),". Its\ntype argument ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," will have a ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),".\nWithout this special case, the parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.add")," would have a\nnullness operator of ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),", too. Then, when a lenient tool would\ncheck whether the ",(0,i.kt)("a",{parentName:"p",href:"#multiple-worlds"},"some-world")," subtyping relation holds for\n",(0,i.kt)("inlineCode",{parentName:"p"},"builder.add(null)"),", it would find that it does."),(0,i.kt)("p",{parentName:"blockquote"},"To solve this, we need a special case for substitution for null-exclusive\ntype parameters like the one on ",(0,i.kt)("inlineCode",{parentName:"p"},"ImmutableList.Builder"),". That special case\nneeds to produce a type with a nullness operator other than ",(0,i.kt)("inlineCode",{parentName:"p"},"UNSPECIFIED"),".\nOne valid option is to produce ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),"; we happened to choose\n",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL"),"."),(0,i.kt)("p",{parentName:"blockquote"},"The choice between ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"MINUS_NULL")," makes little difference\nfor the parameter types of ",(0,i.kt)("inlineCode",{parentName:"p"},"ImmutableList.Builder"),", but it can matter more\nfor other APIs' ",(0,i.kt)("em",{parentName:"p"},"return types"),". For example, consider ",(0,i.kt)("inlineCode",{parentName:"p"},"@NullMarked class\nFoo<E extends @Nullable Object>"),", which somewhere uses the type\n",(0,i.kt)("a",{parentName:"p",href:"https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/FluentIterable.html"},(0,i.kt)("inlineCode",{parentName:"a"},"FluentIterable<E>")),". ",(0,i.kt)("inlineCode",{parentName:"p"},"FluentIterable")," has a method ",(0,i.kt)("inlineCode",{parentName:"p"},"Optional<E>\nfirst()"),". Even when ",(0,i.kt)("inlineCode",{parentName:"p"},"E")," is a type like ",(0,i.kt)("inlineCode",{parentName:"p"},"String UNION_NULL")," (or ",(0,i.kt)("inlineCode",{parentName:"p"},"String\nUNSPECIFIED"),"), we know that ",(0,i.kt)("inlineCode",{parentName:"p"},"first().get()")," will never return ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". To\nsurface that information to tools, we need to define our substitution rule\nto return ",(0,i.kt)("inlineCode",{parentName:"p"},"E MINUS_NULL"),": If we instead used ",(0,i.kt)("inlineCode",{parentName:"p"},"E NO_CHANGE"),", then the\nreturn type would look like it might include ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Otherwise, replace ",(0,i.kt)("inlineCode",{parentName:"p"},"V")," with the result of applying the nullness operator of\n",(0,i.kt)("inlineCode",{parentName:"p"},"V")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"A\u1d62"),"."))),(0,i.kt)("h2",{id:"applying-operator"},"Applying a nullness operator to an augmented type"),(0,i.kt)("p",null,"The process of applying a ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," requires 2 inputs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the nullness operator to apply"),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("a",{parentName:"li",href:"#augmented-type"},"augmented type")," ","(","which, as always, includes a nullness operator for\nthat type) to apply it to")),(0,i.kt)("p",null,"The result of the process is an augmented type."),(0,i.kt)("p",null,"The process is as follows:"),(0,i.kt)("p",null,'First, based on the pair of nullness operators (the one to apply and the one\nfrom the augmented type), compute a "desired nullness operator." Do so by\napplying the following rules in order. Once one condition is met, skip the\nremaining conditions.'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the nullness operator to apply is ",(0,i.kt)("inlineCode",{parentName:"li"},"MINUS_NULL"),", the desired nullness\noperator is ",(0,i.kt)("inlineCode",{parentName:"li"},"MINUS_NULL"),"."),(0,i.kt)("li",{parentName:"ul"},"If either nullness operator is ",(0,i.kt)("inlineCode",{parentName:"li"},"UNION_NULL"),", the desired nullness operator\nis ",(0,i.kt)("inlineCode",{parentName:"li"},"UNION_NULL"),"."),(0,i.kt)("li",{parentName:"ul"},"If either nullness operator is ",(0,i.kt)("inlineCode",{parentName:"li"},"UNSPECIFIED"),", the desired nullness operator\nis ",(0,i.kt)("inlineCode",{parentName:"li"},"UNSPECIFIED"),"."),(0,i.kt)("li",{parentName:"ul"},"The desired nullness operator is ",(0,i.kt)("inlineCode",{parentName:"li"},"NO_CHANGE"),".")),(0,i.kt)("p",null,"Then, if the input augmented type is ",(0,i.kt)("em",{parentName:"p"},"not")," an ",(0,i.kt)("a",{parentName:"p",href:"#intersection-types"},"intersection type"),", the output is\nthe same as the input but with its nullness operator replaced with the desired\nnullness operator."),(0,i.kt)("p",null,"Otherwise, the output is an intersection type. For every element ",(0,i.kt)("inlineCode",{parentName:"p"},"T\u1d62")," of the\ninput type, the output type has an element that is the result of applying the\ndesired nullness operator to ",(0,i.kt)("inlineCode",{parentName:"p"},"T\u1d62"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In this case, the desired nullness operator is always equal to the nullness\noperator to apply that was an input to this process. That's because the\nnullness operator of the intersection type itself is defined to always be\n",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),".")),(0,i.kt)("h2",{id:"capture-conversion"},"Capture conversion"),(0,i.kt)("p",null,"The Java rules are defined in ",(0,i.kt)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10"},"JLS 5.1.10"),". We add to them as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The parameterized type that is the output of the conversion has the same\n",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," as the parameterized type that is the input type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Disregard the JLS rule about ",(0,i.kt)("inlineCode",{parentName:"p"},"<?>"),". Instead, treat ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," like ",(0,i.kt)("inlineCode",{parentName:"p"},"? extends\nObject"),", where the ",(0,i.kt)("a",{parentName:"p",href:"#nullness-operator"},"nullness operator")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," bound is specified by\n",(0,i.kt)("a",{parentName:"p",href:"#unbounded-wildcard"},'"Bound of an unbounded wildcard."')),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"This is just a part of our universal rule to treat a bare ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," like ",(0,i.kt)("inlineCode",{parentName:"p"},"?\nextends Object"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When a rule generates a lower bound that is the null type, we specify that\nits nullness operator is ",(0,i.kt)("inlineCode",{parentName:"p"},"NO_CHANGE"),"."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"See ",(0,i.kt)("a",{parentName:"p",href:"#null-types"},'"Augmented null types."'))))))}m.isMDXComponent=!0}}]);