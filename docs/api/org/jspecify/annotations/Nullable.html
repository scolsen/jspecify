<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (18) -->
<title>Nullable (jspecify 0.0.0-SNAPSHOT API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.jspecify.annotations, annotation type: Nullable">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Field</li>
<li>Required</li>
<li>Optional</li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li>Element</li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li>Optional</li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Element</li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.jspecify.annotations</a></div>
<h1 title="Annotation Interface Nullable" class="title">Annotation Interface Nullable</h1>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="annotations"><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/Documented.html" title="class or interface in java.lang.annotation" class="external-link">@Documented</a>
<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/Target.html" title="class or interface in java.lang.annotation" class="external-link">@Target</a>(<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/ElementType.html#TYPE_USE" title="class or interface in java.lang.annotation" class="external-link">TYPE_USE</a>)
<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/Retention.html" title="class or interface in java.lang.annotation" class="external-link">@Retention</a>(<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/RetentionPolicy.html#RUNTIME" title="class or interface in java.lang.annotation" class="external-link">RUNTIME</a>)
</span><span class="modifiers">public @interface </span><span class="element-name type-name-label">Nullable</span></div>
<div class="block">Indicates that the annotated <a href="https://github.com/jspecify/jspecify/wiki/type-usages">type
 usage</a> (commonly a parameter type or return type) is considered to include <code>null</code> as a
 value.

 <p>Example usages:

 <pre><code>
 @Nullable String field;

 @Nullable String getField() { return field; }

 void setField(@Nullable String value) { field = value; }

 List&lt;@Nullable String&gt; getList() { â€¦ }
 </code></pre>

 <p>For a comprehensive introduction to JSpecify, please see <a href="http://jspecify.org">jspecify.org</a>.

 <p><b>Warning:</b> These annotations are under development, and <b>any</b> aspect of their
 naming, locations, or design is subject to change until the JSpecify 1.0 release. Moreover,
 supporting analysis tools will be tracking the changes on varying schedules. Releasing a library
 using these annotations in its API is <b>strongly discouraged</b> at this time.

 <h2>Meaning per each kind of type usage</h2>

 <p>The essential meaning of this annotation is always the same: the type it annotates is
 considered to include <code>null</code> as a value. But this may affect your code a little differently
 based on the kind of type usage involved.

 <ul>
   <li>On a <b>parameter type</b>: The <code>setField</code> method (at top) permissively accepts a
       "string-or-null", meaning that it is okay to pass an actual string, or to pass <code>
       null</code>. (This doesn't guarantee that passing <code>null</code> won't produce an exception at
       runtime, but it should be much less likely.) This also applies to the type of a lambda
       expression parameter, if that type is given explicitly (otherwise its nullness must be
       inferred from context).
   <li>On a <b>method return type</b>: The <code>getField</code> method returns a "string-or-null", so
       while the caller might get a string back, it should also address the possibility of getting
       <code>null</code> instead. (This doesn't guarantee there is any circumstance in which <code>
       null</code> <i>will</i> actually be returned.)
   <li>On a <b>field type</b>: The <code>field</code> field has the type "string-or-null", so at times
       it might hold a string, and at times it might hold <code>null</code>. (Of course, every field of
       a reference type <i>originally</i> holds <code>null</code>, but as long as the class ensures
       that its uninitialized states can't be observed, it's appropriate to overlook that fact.)
   <li>On a <b>type argument</b>: A type usage of "nullable string" appears <i>within</i> the
       compound type <code>List&lt;@Nullable String&gt;</code>. No matter how this type is used (return type,
       etc.), this means the same thing: every appearance of <code>E</code> in <code>List</code>'s member
       signatures will be considered nullable. For a list, this means it may contain null
       <i>elements</i>. If the list reference itself might be null as well, we can write
       <code>@Nullable List&lt;@Nullable String&gt;</code>, a "nullable list of nullable strings".
   <li>On the upper bound of a <b>type parameter</b>: For example, as seen in <code>class List&lt;E
       extends @Nullable Object&gt;</code>. This means that a <i>type argument</i> supplied for that type
       parameter is permitted to be nullable if desired: <code>List&lt;@Nullable String&gt;</code>. (A
       non-null type argument, as in <code>List&lt;String&gt;</code>, is permitted either way.)
   <li>On a usage of a <b>type variable</b>: A type parameter, like the <code>E</code> in <code>
       interface List&lt;E&gt;</code>, defines a "type variable" of the same name, usable only <i>within</i>
       the scope of the declaring API element. In any example using <code>String</code> above, a type
       variable like <code>E</code> might appear instead. <code>@Nullable</code> continues to mean "or null"
       as always, but notably, this works without regard to whether the type argument is
       <i>already</i> nullable. For example, suppose that <code>class Foo&lt;E extends @Nullable
       Object&gt;</code> has a method <code>@Nullable E eOrNull()</code>. Then, whether <code>foo</code> is of type
       <code>Foo&lt;String&gt;</code> or <code>Foo&lt;@Nullable String&gt;</code>, the expression <code>foo.eOrNull()</code>
       is nullable either way. Using <code>@Nullable E</code> in this way is called "nullable
       projection" (<a href="NonNull.html#projection">non-null projection</a> is likewise
       supported, but less commonly useful).
   <li>On a <b>nested type</b>: In most examples above, in place of <code>String</code> we might use a
       nested type such as <code>Map.Entry</code>. The Java syntax for annotating such a type as
       nullable looks like <code>Map.@Nullable Entry</code>.
   <li>On a <b>record component</b>: As expected, <code>@Nullable</code> here applies equally to the
       corresponding parameter type of the canonical constructor, and to the return type of a
       generated accessor method as well. If an explicit accessor method is provided for this
       record component, it must still be annotated explicitly. Any non-null components should be
       checked (for example using <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Objects.html#requireNonNull(T)" title="class or interface in java.util" class="external-link"><code>Objects.requireNonNull(T)</code></a>) in a <a href="https://docs.oracle.com/en/java/javase/19/language/records.html">compact
       constructor</a>.
 </ul>

 <h2 id="applicability">Where it is applicable</h2>

 <p>This annotation and <a href="NonNull.html" title="annotation interface in org.jspecify.annotations"><code>NonNull</code></a> are applicable to any <a href="https://github.com/jspecify/jspecify/wiki/type-usages">type usage</a> <b>except</b> the
 following cases, where they have no defined meaning:

 <ul>
   <li>On any<b> intrinsically non-null type usage</b>. Some type usages are incapable of
       including <code>null</code> by the rules of the Java language. Examples include any usage of a
       primitive type, the argument to <code>instanceof</code>, a method return type in an annotation
       interface, or the type following <code>throws</code> or <code>catch</code>. In such locations, a
       nullness annotation could only be contradictory (<code>@Nullable</code>) or redundant
       (<code>@NonNull</code>).
   <li>On the root type of a <b>local variable</b> declaration. The nullness of a local variable
       itself is not a fixed declarative property of its <i>type</i>. Rather it should be inferred
       from the nullness of each expression assigned to the variable, possibly changing over time.
       (<a href="https://bit.ly/3ppb8ZC">Why?</a>). Subcomponents of the type (type arguments,
       array component types) are annotatable as usual.
   <li>On the root type in a <b>cast expression</b>. To inform an analyzer that an expression it
       sees as nullable is truly non-null, use an assertion or a method like <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Objects.html#requireNonNull(T)" title="class or interface in java.util" class="external-link"><code>Objects.requireNonNull(T)</code></a>. (<a href="https://bit.ly/3ppb8ZC">Why?</a>)
       Subcomponents of the type (type arguments, array component types) are annotatable as usual.
   <li>On any part of a <b>receiver parameter</b> type (<a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-8.html#jls-8.4">JLS 8.4</a>).
   <li>If both <code>@Nullable</code> and <code>@NonNull</code> appear on the same type usage,
       <i>neither</i> one is recognized.
 </ul>

 Whether the code is <a href="NullMarked.html" title="annotation interface in org.jspecify.annotations"><code>NullMarked</code></a> also has no consequence in the above locations.

 <h2>Unannotated type usages</h2>

 <p>For a type usage where nullness annotations are <a href="#applicability">applicable</a> but
 not present, its nullness depends on whether it appears within <a href="NullMarked.html" title="annotation interface in org.jspecify.annotations">null-marked</a> code; see that class for details. Note in particular that nullness information from
 a superclass is never automatically "inherited".</div>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
